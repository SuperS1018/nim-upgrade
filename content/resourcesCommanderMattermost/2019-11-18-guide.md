---
title: Guide
status: Published
index: '2'
anchor-subject:
  - anchor-item: []
    body: ''
    title: Developer Guide
  - anchor-item:
      - body: >-
          Commander provides a full development and runtime environment for
          developing custom Mattermost apps. There are a number of advantages to
          using Commander to develop, host, and maintain your custom apps.


          ### You don’t need your own server


          Commander lets you host and run Mattermost apps in the Nimbella Cloud,
          so you don’t have to deploy your own server. After you create a
          listing for your custom app on the Mattermost API apps page, you
          create one slash command and point the slash command’s Request URL to
          a Commander URL. Your app’s custom code lives in the Nimbella cloud,
          and Nimbella servers respond to slash commands developed for your
          app. 


          The slash command you create for your custom app at the Mattermost API
          site serves as a command prefix for your app’s commands. When users
          run commands for the app, they always begin with this prefix. For
          example, if you have a custom app called DevOps with a command prefix
          of `/devops`, then your app responds to any slash commands that have
          the form `/devops <command>`.


          ### Selective listening


          Most custom Mattermost apps function as bots, listening to all
          messages in a public channel and responding to direct requests. The
          apps you create with Commander don't read messages in channels. They
          only respond to slash commands with the appropriate command prefix.
          This means you don't have to worry about your custom Mattermost app
          reading messages in your public or private channels.


          ### Create custom commands and administer your app right in Mattermost


          After you install the Commander app in Mattermost, you can create
          custom slash commands and administer your custom app from the
          Mattermost interface. See the tutorial in the [Quickstart
          Guide](/docs/commander/mattermost/quickstart) for an example of
          creating a custom slash command in the Mattermost UI.


          ### Easy to code


          Commands are written in JavaScript, and premium versions of Commander
          allow other options such as the Node.js runtime. This means custom
          apps can be developed by app developers or even DevOps staff who know
          shell scripting.


          ### Advanced features


          * Administrators assign [user roles]($create-manage-user-roles-groups)
          to control who can administer your custom app, who can write code for
          the commands, and who can run the slash commands.

          * You can set up [recurring tasks]($tasks) and [triggers]($triggers)
          that run commands without user input.

          * You can create encrypted parameter values, called
          [secrets]($secrets), which keep sensitive information from being
          viewed by users or being stored in Mattermost’s history.

          * You can import and export [command sets]($command-sets) to either
          use someone else’s code or share your own.


          ### Security


          There's nothing you need to do to secure your app. The signatures of
          incoming requests from Mattermost users issuing slash commands are
          verified to ensure they are coming from Mattermost. See
          [Security]($security).
        title: Mattermost apps with Nimbella Commander
    body: >-
      Mattermost allows the use of custom  apps, which are accessed in
      Mattermost by means of [Slash
      Commands](https://api.slack.com/interactivity/slash-commands). When a user
      types a specific slash command like `/times`, it sends a message to a
      public URL. The request includes the command and any additional text
      following the command. Mattermost calls the public URL a Request URL.
      Custom Mattermost apps and slash commands are created by following steps
      1-4 in Quickstart.
    title: Mattermost Apps
  - body: >-
      Check out the Commander [Overview](/docs/commander/mattermost/overview)
      and then use the [Quickstart](/docs/commander/mattermost/quickstart) to
      get started. Then follow this Developer Guide to understand where to go
      from there. Once you’re proficient, you’ll be able to look up commands in
      the [Commander Reference Guide](/docs/commander/mattermost/reference) if
      you need a quick reminder.
    title: Ready to get started?
  - anchor-item:
      - body: >-
          Commander `/nc`  slash commands rely on the concept of a current app.
          If you are just creating commands that run with `/nc` itself, you only
          have one app you are working with, the “nc” app. So, if you are just
          developing commands that run with the `/nc` prefix, your current app
          will always be “nc”.


          If you create a custom Mattermost app and connect that custom app to
          Commander with the
          [app_add](/docs/commander/mattermost/reference#app_add) command, that
          app will become your “current app”. If you have multiple apps in your
          workspace, you can use the
          [app_current](/docs/commander/mattermost/reference#app_current)
          command to verify which app is being treated as the current app or
          make another app the current one.


          **Show the current app:**


          > ##### /nc app_current

          >

          > ###### Your current app is devops


          Switch to the accounting app: 


          > ##### /nc app_current accounting
        title: The current app
      - body: >-
          Commands support a variety of parameter definitions and Commander
          automatically parses parameters so they can be accessed easily in your
          source code. 


          When you create a command, you specify the parameters the command
          takes by enclosing parameter names in angle brackets. For example, the
          following
          [command_create](/docs/commander/mattermost/reference#command_create)
          command creates a command for your custom app that will take two
          parameters:


          > ##### /nc command_create add_host <hostname> <ip_addr>


          In the code for the command, you can access the command's parameters
          by name using params:


          ```

          if (params.hostname == 'a.nimbella.com') {

          ```


          But also, the default generated command source code creates local
          variables as a convenience:


          ```
           const {
              Hostname,
              Ip_addr
            } = params;
          ```


          This means you can access the parameters by name in a function without
          params:


          ```

          if (hostname == 'a.nimbella.com') {

          ```


          When a user runs this command in Mattermost, they add parameter values
          as in the following example (assuming the command prefix for the
          custom app is `/devops`):


          > ##### /devops add_host a.com 100.200.3.4


          If you’re working on a command and discover you want to change the
          command's parameters, you can change them with the command_params
          command. For example, if you wanted to add a TTL parameter to the
          add_host command you created above:


          > ##### /nc command_params add_host <hostname> <ip_addr> <ttl>


          **Note:** If you use /nc command_params to create new parameters, the
          command source code is not regenerated, so to access those parameters
          directly by name without using `params`, you'll need to add them to
          the list of local variables in the code first.


          ### Parameter values with white space


          When a command is run in your custom app, parameter values that
          include white space should be enclosed in a pair of either double or
          single quotes. For example, if you have a `print` command with a
          `<msg>` parameter, the value could be:


          > ##### /devops print "This parameter has multiple words"


          This command passes the value `This parameter has multiple words` to
          the command source. If you want to pass a parameter value that
          includes the double quotes, use single quotes to enclose the string,
          such as: 


          > ##### /devops print ‘“Life is what happens when you're busy making
          other plans.” - John Lennon’


          **Note:** On Apple computers (and potentially others), double quotes
          appear entered as either Unicode left or right double quotes. If the
          string starts with a Unicode left quote, a Unicode right quote will be
          expected to end it.


          ### Optional command parameter


          A list of parameters can end with one optional parameter in square
          brackets, such as the `[<ttl>]` parameter in this example:


          CMS-COMMANDERCOMMANDS ROLE=user INDENT=0 MESSAGE=/nc command_create
          add_host <hostname> <ip_addr> \[<ttl>]


          This command can be run with either the first two parameters or all
          three, so either of these commands is valid:


          > ##### /devops add_host a.nimbella.com 1.2.3.4

          >

          > ##### /devops add_host a.nimbella.com 1.2.3.4 300


          ### Parameter options


          The parameter definition for a command can also include options.
          Options are preceded with a hyphen (-). Options can be either be flags
          or named options. Here's an example that contains a flag option
          `-detail` and a named option `-ttl` with value `ttl_value`:


          CMS-COMMANDERCOMMANDS ROLE=user INDENT=0 MESSAGE=/nc command_create
          add_host <hostname> <ip_addr> \[-detail] \[-ttl <ttl_value>]


          In the source code for the command, you can check to see if a flag
          option is present either by using the params variable:


          ```

          if (params.detail) {

          ```


          or by its name alone, because the default generated code creates a
          local variable with the name of the option:


          ```

          if (detail) {

          ```


          Similarly, you can check if a named option exists by its name alone
          and check its value using the name of the value:


          ```

          if (ttl && ttl_value == 30) {

          ```


          The `add_host` command created above with the `-detail` and `-ttl`
          options can be run in any of the following ways:


          > ##### /devops add_host a.com 1.2.3.4

          >

          > ##### /devops add_host a.com 1.2.3.4 -detail

          >

          > ##### /devops add_host a.com 1.2.3.4 -ttl 90 -detail


          **Note:**


          * Options may not be used when an optional command parameter is
          present.

          * When options are specified, they must be specified at the end of the
          parameter definition.


          ### Variable number of arguments


          Command parameter definitions support `varargs`, a variable number of
          arguments. A parameter definition for a command with `varargs` ends
          with the ellipsis notation (…). The following example  specifies that
          the `add_host` command can take any number of parameters:


          > ##### /nc command_create add_host ...


          When `varargs` is used, you must code the command parameters to be
          parsed. In the command source code, the text of the full command,
          including the command prefix and all parameters, is available in
          `commandText`:


          ```

          let parts = commandText.split(" ");

          let cmdPrefix = parts[0];

          let cmd = parts[1];

          ```


          **Note:** If you use `varargs`, your parameter definition cannot
          include any [optional command
          parameters]($h3-optional-command-parameter) or [parameter
          options]($h3-parameter-options).
        title: Command Parameters
    body: >-
      The Nimbella Commander app for Mattermost lets you control nearly all of
      the administrative functions for your custom app directly in the
      Mattermost interface by running slash commands with the command prefix
      `/nc`.  The entire set of Commander commands is listed in the [Reference
      Guide](/docs/commander/mattermost/reference). This Developer Guide also
      contains many examples of these commands, grouped by administrative
      function.
    title: About commands
  - anchor-item:
      - anchor: Create a /devops slash Command
        body: >-
          Make sure you’re logged into your Mattermost workspace before
          starting. 


          1. Click **Create New App **by following steps 1-4 of Quickstart.
             For **AppName**, enter **DevOps**.
        title: Create a /devops Slash Command Prefix
      - anchor: Connect the App
        body: >-
          Adding the request URL in the new slash command connects the app to
          Commander
        title: Connect the App to Commander
      - anchor: Create a Print Command
        body: >-
          Now we’re ready to create our first command in our DevOps app. We’ll
          use Commander right in Mattermost to create a `print` command, with a
          parameter that we can then use for various types of notifications in
          our DevOps app. We’ll use this command in our GitHub example in the
          Triggers section to notify us that something has changed in our GitHub
          repository.


          1. In Mattermost, enter the following slash command exactly as it
          appears here, including the angle  brackets:


          CMS-COMMANDERCOMMANDS ROLE=user INDENT=1 MESSAGE=/nc command_create
          print <msg>


          CMS-INDENT INDENT=1 CONTENT=You’ll see a response similar to the
          following:


          CMS-COMMANDERCOMMANDS ROLE=admin INDENT=1 MESSAGE=Created command
          print <msg>, edit the code


          2. Click the link to edit the Commander code for the command.

          3. Find this line in the source code:
             ```
             "This is a default response for a newly created command with text: " + commandText
             ```
             Change the line to this:
             ```
             text: msg
             ```
          4. Click **Save**.

          5. In Mattermost, test the command by entering the command prefix
          (`devops`), followed by the command (`print`), followed by a text
          string for the `msg` parameter


          CMS-COMMANDERCOMMANDS ROLE=user INDENT=1 MESSAGE=/devops print Howdy!


          CMS-INDENT INDENT=1 CONTENT=If your `print` message has more than one
          word, surround it with single or double quotes or else you’ll get a
          response that a parameter was not found.

          You should see the Mattermost response shown in this screenshot,
          coming from your custom app and displaying the print message.


          CMS-IMAGECLASS IMAGE=/images/uploads/print-command-howdy.png INDENT=1
          CLASS=undefined ALT=Howdy


          Note that we created the command with an`/nc` slash command, but we
          ran the command in in our DevOps app with our `/devops` command
          prefix.
        title: Create a Print Command
    body: >-
      Now we’ll create a custom Mattermost app with its own command prefix,
      which involves the following tasks:


      _(these links need to be updated)_


      1. Create a Mattermost integration for the DevOps team.
         The app could eventually contain a number of slash commands to accomplish tasks that DevOps normally performs.
      2. [Create a slash command]($create-a--devops-slash-command) called
      /devops.
         We’ll create a slash command in the DevOps app that will serve as a command prefix when you run commands in Mattermost. 
      3. [Connect the slash command to Commander]($connect-the-app).

      4. [Create a print command]($create-a-print-command) that can be used for
      various notifications.
    title: Create/manage custom apps
  - anchor-item:
      - body: >-
          If your command source code is written in JavaScript and your command
          requires additional npm (Node Package Manager) packages to run, you
          can install them in your JavaScript source code with this function,
          which accepts an array of npm packages to install:


          ```

          async function install(pkgs) {
            pkgs = pkgs.join(' ');
            return new Promise((resolve, reject) => {
              const { exec } = require('child_process');
              exec(`npm install ${pkgs}`, (err, stdout, stderr) => {
                if (err) reject(err);
                else resolve();
              });
            });
          }

          ```


          The following example shows the `install()` function being used to
          install two npm packages:


          ```

          let packages = [ 'read-installed', 'chalk' ];

          await install(packages);

          ```


          After installing the npm packages, they can be used as they normally
          would with `require()`. This example shows the read-installed package
          being used:


          ```

          var readInstalled = require('read-installed');

          readInstalled("/", { depth: 0, dev: true }, function(err, map) { … })

          ```


          **Note:** The installation of npm packages takes a little time, so
          commands that install packages will start up slower than those that do
          not.


          To speed up subsequent runs of a command function that installs
          packages, the package references returned from the `require()`
          statement can be moved into global variables in the command source
          code and the packages are only loaded if those values are undefined.
          This method will cause the packages to be installed the first time the
          command is executed. Note that they do not need to be installed if the
          same execution environment is used again by the underling serverless
          platform. When serverless function environments are reused in a
          serverless platform, the globals can maintain their previous values.


          For example, if the `readInstalled` variable above was global, the
          code could look like this:


          ```

          var readInstalled;

          function _command(...) {
            if (!readInstalled) {
              let packages = [ 'read-installed', 'chalk' ];
              await install(packages);
              readInstalled = require('read-installed');
            }
          }

          ```


          The first time the code is executed, `readInstalled` is undefined and
          the packages loaded. If the environment is reused later by the
          underlying serverless platform, the `readInstalled` value can be used
          without installing the packages.
        title: Add npm packages for a command
    body: >-
      **Create a command for your custom app**


      Use [command_create](/docs/commander/mattermost/reference#command_create)
      to create custom slash commands for the current app. Put
      [parameters]($command-parameters) to be created in angle brackets.


      * Create an `add_host` command with parameters for hostname and IP
      address:
        > ##### /nc command_create add_host <hostname> <ip_addr>

       Outputs a link to the Nimbella Cloud command source code, which you edit. 

      If you lose this link or want to go back to it later, use the
      [command_code](/docs/commander/mattermost/reference#command_code) command.


      See the tutorial in the [Quickstart
      Guide](/docs/commander/mattermost/quickstart) for a detailed example of
      creating the command in Mattermost and following the link to add code.


      **Retrieve the source code link for a command**


      Use [command_code](/docs/commander/mattermost/reference#command_code) to
      retrieve the link to the source code for a command you’ve already created.
      A link is generated that will work for 24 hours.


      * Retrieve the code link for the `add_host` command:
        > ##### /nc command_code add_host

      **List all commands in the current app**


      Use [command_list](/docs/commander/mattermost/reference#command_list). 


      * List all of the commands in the current app:
        > ##### /nc command_list

      **Info about a command**


      Use [command_info](/docs/commander/mattermost/reference#command_info) to
      get the following information about an individual command:


      * When it was created

      * Who created it

      * When the source was last modified

      * Who modified the source


      This information appears in the command output.


      * Get information about the `add_host` command:
        > ##### /nc command_info add_host

      **View or set a command’s short description**


      Commands have a short description that describes what they are or what
      they do. Use
      [command_desc](/docs/commander/mattermost/reference#command_desc) to view
      or create the short description. If you’re adding a description that has
      white space, enclose the value in single or double quotes.


      * View the short description of the `add_host` command:
        > ##### /nc command_desc add_host
      * Set the short description of the `add_host` command:
        > ##### /nc command_desc add_host "Adds a hostname"

      **Call a webhook for a command**


      Commander automatically executes the source code for a command when it is
      run in Mattermost. If you don't want the command to automatically run its
      source code, you can set it to call a webhook instead with
      [command_webhook](/docs/commander/mattermost/reference#command_webhook).
      When a webhook is set up for a command, the associated webhook URL will be
      contacted and its result returned to Mattermost instead of running the
      command's source code.


      **Tip:** A command webhook can be useful when developing code. Use a
      webhook relay to proxy a command to your local development machine to
      develop and debug the command source code locally. After setting up a
      webhook relay to your local machine, you can run a Node server locally
      that will execute the command when it is run in Mattermost.


      * Set up a webhook with the URL of the webhook relay to contact when the
      `add_host` command is run:
        > ##### /nc command_webhook add_host https://m.mywebhookrelay09.com/F07173

      You can revert to executing the source code for the command by first
      clearing the webhook, then using retrieve the link to the code editor to
      save the command code.


      * Turn off the `add_host` command webhook:
        > ##### /nc command_webhook add_host clear
      * Retrieve the link to the code editor to save the `add_host` source code
      and return to running the command normally:
        > ##### /nc command_code add_host

      If you need to, you can use
      [command_log](/docs/commander/mattermost/reference#command_log) to get the
      log history of the command to see who ran the command at what times and
      also the time it took the command to execute. See the [Logs]($logs)
      section for more information.


      * Get the log history of the add_host command:
        > ##### /nc command_log add_host

      **Delete a command**


      Use [command_delete](/docs/commander/mattermost/reference#command_delete)
      plus the command name.


      * Delete the `add_host` command:
        > ##### /nc command_delete add_host
    title: Create/manage commands
  - anchor-item:
      - body: >-
          For examples of assigning these user roles, see [Commands to manage
          users and user groups]($commands-to-manage-users-and-user-groups).


          ### Admin


          In Commander, every custom Mattermost app starts with one
          administrative user: the Mattermost user who initially adds the custom
          app to Commander. It’s up to that admin to assign other  users as
          admins for that app. Admins in turn can assign users as coders for
          specific commands in the app and as runners of specific commands in
          the app. 


          Admins can also create user groups to make it easier to set coder and
          runner roles for multiple users. See the command examples below.


          Admins have no restrictions on what they can do when it comes to an
          app. Only admin users can create commands, assign roles to other
          users, and perform other administrative tasks. Admins can do anything
          that coders and runners can do.


          ### Coder


          The coder role is associated with specific commands. A Mattermost user
          with a coder role for a command is allowed to edit the source code for
          the command and also run the command. App admins manage the list of
          coders for commands. Coders are automatically runners for the commands
          they can edit.


          ### Runner


          The runner role is associated with specific commands ii the custom
          app. A Mattermost user with a runner role for a command is allowed to
          run that command. They cannot run commands in the Commander app.
        title: About user roles
      - body: >-
          Instead of assigning Coder and Runner roles to individual users,
          admins can combine users into user groups to make it easier to set
          coder and runner roles for multiple users. The entire user group can
          then be added or removed as coders or runners for a command.
        title: About user groups
      - body: >-
          ### Manage admin users


          Use the [app_admins](/docs/commander/mattermost/reference#app_admins)
          command to list, add, or remove Mattermost users as admins for the
          current app. A plus (+) in front of a user name adds the user to the
          list and a minus (-) removes a user from the list. 


          **Note:** There must be a space between the plus (+) and minus (-)
          signs and the user to be added or removed as admins for the current
          app. 


          * **List the users who are admins for the current app:**
            > ##### /nc app_admins
            >
            > ###### devops admins: Sam, Jill
          * **Add Bill and Mary and remove Larry as admins for the current
          app:**
            > ##### /nc app_admins + @Bill + @Mary - @Larry

          ### Manage coder users


          Use
          [command_coders](/docs/commander/mattermost/reference#command_coders)
          to list, add, or remove users as coders for particular commands.


          * **View the current list of coders for the add_host  command:**
            > ##### /nc command_coders add_host
          * **Add Jim and Bob and remove John as coders for the print command:**
            > ##### /nc command_coders print + @Jim + @Bob - @John

          ### Manage users who run commands


          Use
          [command_runners](/docs/commander/mattermost/reference#command_runners)
          to list, add, or remove users as runners for particular custom
          commands.


          * **Add Joe and Sue and remove John as runners for the print
          command:**
            > ##### /nc command_runners print + @Joe + @Sue - @John

          ### Allow anyone to run a custom command


          There is a special user group that always exists called `anyone`,
          which includes every Mattermost user. If you want to allow a command
          to be run by `anyone`, you can add the anyone group to the list of
          command  runners:


          * **Let anyone run the print command: **
            > ##### /nc command_runners print + anyone

          ### Create user groups


          Use [group_create](/docs/commander/mattermost/reference#group_create)
          to create a user group.


          * **Create a user group called devgroup1:**
            > ##### /nc group_create devgroup1

          ### List, add, or remove members of a user group


          Use the
          [group_members](/docs/commander/mattermost/reference#group_members)
          command.


          * **Add Sue to devgroup1:**
            > ##### /nc group_members devgroup1 + @Sue
          * **Add Jim, Bob, and John and remove Sue from devgroup1:**
            > ##### /nc group_members devgroup1 + @Jim + @Bob + John - @Sue
          * **List the members of devgroup1:**
            > ##### /nc group_members devgroup1
            >
            > ###### devgroup1 members: Jim, Bob, John

          ### List all user groups


          Use the [group_list
          ](/docs/commander/mattermost/reference#group_list)command.


          * **List all user groups for the current app.**
            > ##### /nc group_list
            >
            > ###### devgroup1

          ### Delete a user group


          Use the
          [group_delete](/docs/commander/mattermost/reference#group_delete)
          command to delete a user group. Only the named group of users is
          deleted, the command does not affect the Mattermost users themselves
          in any way.


          * **Delete the user group devgroup1:**
            > ##### /nc group_delete devgroup1

          ### Add a user group to a command


          We gave examples of using
          [command_coders](/docs/commander/mattermost/reference#command_coders)
          and
          [command_runners](/docs/commander/mattermost/reference#command_runners)
          to add users as coders and runners respectively. Here are two examples
          of adding a user group instead.


          * **Add the user group devgroup1 as coders for the print command:**
            > ##### /nc command_coders print + devgroup1
          * **Add the user group bookkeeping as runners for the bills command:**
            > ##### /nc command_runners bills + bookkeeping
        title: Commands to manage users and user groups
    body: |-
      There are three user roles, described in detail in the following sections:

      * [Admin]($h3-admin)
      * [Coder]($h3-coder)
      * [Runner]($h3-runner)
    title: Create/manage user roles/groups
  - anchor-item:
      - body: >-
          Use the
          [secret_list](/docs/commander/mattermost/reference#secret_list)
          command.


          * List the current app’s secret key-value pairs:

            > ##### /nc secret_list

            The output is a list of keys with their encrypted values. Only the beginning and end of the encrypted values are shown for each secret because the encrypted values can get rather long.
        title: View an app’s secret key-value pairs
      - body: >-
          Use the
          [secret_delete](/docs/commander/mattermost/reference#secret_delete)
          command in Mattermost with the name of the secret key.


          * Delete the secret key-value pair named `gc_key`:
            > ##### /nc secret_delete gc_key
        title: Delete a secret
      - body: >-
          Once added to your app, decrypted secret values can be accessed in
          source code using the `secrets` input parameter. 


          * Example code that accesses a secret value with the key
          `mySecretApiKey`:
            ```
            async function my_command(params, text, secrets = {}) {
              if (!secrets.mySecretApiKey) {
                return { text: "you need a mySecretApiKey secret to run this command" };
              }
              .. connect to API using secrets.mySecretApiKey ..
            }
            ```
          * Look in the command source code under the secrets input parameter.
          For example:
            ```
            awsConnection = createAwsConnection(secrets.awsKey);
            gwpConnection = createGwpConnection(secrets.gwpKey);
            …
            ```
        title: Access the decrypted value of a secret in your command code
    body: >-
      Admins can create secrets, which are key-value pairs in which the value is
      encrypted. The key is an arbitrary name, and the value represents an input
      parameter that should not be visible, such as an API key or password. When
      secret keys are used as input parameters in commands, the values are
      automatically decrypted and appear as input parameters to the source code.


      Commander has a Secret Creator web user interface (UI) in which you create
      the key-value pairs and and the secret values are encrypted and stored.
      That way, unencrypted secret values are stored outside of your app's
      source code and never appear in plain text in Mattermost. Only admins have
      access to the Secret Creator.


      Each Mattermost app contains a unique encryption key to encrypt the values
      for all key-value pairs. Secrets encrypted for one app can't be decrypted
      by any other app. The encrypted values are stored in your app using
      AES-256-bit symmetric encryption. 


      Here’s an overview of how secrets are created, with detailed procedures
      below:


      * Use the `secrete_create` command in Mattermost, which outputs a link to
      the Secret Creator.

      * Create the key-value name pairs in the Secret Creator and click a button
      to encrypt the values.
        The Secret Creator outputs a `secret_add` command for each key-value pair you’ve created.
      * Copy and paste the `secret_add` commands into Mattermost to add them to
      your app.


      **Note:** All commands for creating and managing secrets require an admin
      user role, but secrets can be listed by anyone with access to the
      [secret_list](/docs/commander/mattermost/reference#secret_list) command.
      The output of all of these commands is visible in the Mattermost channel
      in which they are run, but the parameter value is always encrypted.


      Here are examples of procedures related to secrets.


      **Create secret key-value pairs and add them to your app:**


      1. Enter the following command into Mattermost:
         > ##### /nc secret_create
         >
         > ###### click here to access the Secret Creator
      2. In the Secret Creator UI, add a set of name-value pairs, then click
      **Make Secrets**. 
         The Secret Creator outputs a list of secret_add commands, as in this example:
         > ##### /nc secret_add awsKey NFa\_305fe79...c21e4285385f17\_
         >
         > ##### /nc secret_add gwpKey NFa\_5c67f7b...85e915084650f6\_
      3. Copy and paste each
      [secret_add](/docs/commander/mattermost/reference#secret_add) command from
      the Secret Creator output into Mattermost to add the encrypted key-value
      pairs to your current app.
    title: Secrets
  - body: >-
      Commander has three log commands to view logs for an app, command, or user
      respectively:


      * [app_log](/docs/commander/mattermost/reference#app_log)

      * [command_log](/docs/commander/mattermost/reference#command_log)

      * [user_log](/docs/commander/mattermost/reference#user_log)


      The log commands are straightforward and currently only have the
      functionality to display the logs. Here are examples of each being used:


      * Show the log for the [current app]($the-current-app):
        > ##### /nc app_log

         Output example:

        > ###### 343. user_log @Joe Ran by @Joe 10/18/2019, 12:19:13 AM (App: /devops)
        
        > ###### 342. command_code print Ran by @Joe 10/17/2019, 11:26:08 PM (App: /devops)
      * Show the log for the `add_host` command:
        > ##### /nc command_log print

         Output example:

        > ###### 8. print Ran by @Joe 10/17/2019, 6:49:34 PM Execution time 125ms with status 200 (App: /devops)
        >
        > ###### 7. print Ran by @Joe 10/17/2019, 1:30:53 PM Execution time 122ms with status 200 (App: /devops)
      * Show the log for user `@Sam`:
        > ##### /nc user_log @Sam

         Output example: 

        > ###### 404. command_delete print Ran by @Sam 10/17/2019, 6:49:20 PM (App: /devops)
        
        > ###### 403. command_list Ran by @Sam 10/17/2019, 6:48:20 PM (App: /devops)

      **Tip:** Every log has a line number. To go back in history, log commands
      support a `-from` option with a line number parameter, for example:


      > ##### /nc app_log -from 90

      >

      > ##### /nc command_log add_host -from 210

      >

      > ##### /nc user_log @Rick -from 300


      More advanced features, such as searching logs and allowing them to be
      exported will be supported in future releases.
    title: Logs
  - anchor-item:
      - body: >-
          In Commander, a channel is associated with an incoming webhook that
          can post into that channel. To allow your app to post in a channel,
          you must first create an incoming webhook for that channel in a custom
          Mattermost app, then add it to Commander using the
          [channel_add](/docs/commander/mattermost/reference#channel_add)
          command. You can use this command with a public, private or locked
          channel. When you add a channel, a message is posted into that channel
          to let you know the channel was added to Commander.


          Here’s how to create a channel and add it to Commander. In this
          example, let’s add a channel called `#devops-output` to the custom
          DevOps app that was created in the [Quickstart
          Guide](/docs/commander/mattermost/quickstart). 


          **To create a channel in your custom Mattermost app:**


          1. If you want to use a channel other than one that already exists in
          Mattermost, create it.
             In this example, we created a `#devops-output` channel.
          2. Select the DevOps app.

          3. Click** Add features and functionality**.

          4. Click** Incoming Webhooks**.

          5. Enable **Incoming Webhooks**.

          6. Click **Add New Webhook to Workspace**.

          7. Select the channel you want the task to output to and click
          **Allow**.

          8. Click **Copy** for the webhook URL you just created.

          9. In Mattermost, run the following command, substituting the values
          for channel name and webhook URL:


          > ##### /nc channel_add #devops-output <webhook URL>

            Replace <webhook URL> by pasting in the webhook URL that you copied in the previous step.

            Example:

          > ##### /nc channel_add #devops-output
          https://nimbella.test.mattermost.cloud/hooks/ki934tah3pf8jgbcss6gyym8fo


          **Note:** After you add the channel, you need to set the channel for
          your task or trigger. See the [Tasks]($tasks) and
          [Triggers]($triggers) sections for example commands.
        title: Create/add a channel
      - body: |-
          Use the channel_list command.

          * To list all channels added to the [current app]($the-current-app):
            > ##### /nc channel_list
        title: List channels added to your app
      - body: >-
          Use the
          [channel_delete](/docs/commander/mattermost/reference#channel_delete)
          command with the channel name as a parameter. 


          * Delete the `#devops-output` channel from Commander:
            > ##### /nc channel_delete #devops-output

          **Note:** This command does not delete the channel's incoming webhook
          from Mattermost. To delete the channel's incoming webhook, delete it
          from Mattermost integrations.
        title: Delete a channel
    body: >-
      By default, Mattermost apps that use Commander can only output to
      Mattermost in response to a slash command. [Tasks]($tasks), which run a
      command at an interval or rate, and [triggers]($triggers), which connect
      external webhooks to commands, aren’t run by users, so they require the
      ability to post to a Mattermost channel on their own. Commander includes
      channel commands that enable triggers and tasks to post in channels on
      their own.


      **Note:** If you aren't using tasks or triggers, you don't need to add
      channels to your app
    title: Channels
  - anchor-item:
      - body: >-
          Use the
          [task_create](/docs/commander/mattermost/reference#task_create)
          command with parameters for the task name, output channel, and the
          command to run.


          Create a task called `mytask`, output to the `#general` channel, and
          run the `print` command with the parameter “`Hello World`”:


          > ##### /nc task_create mytask #general print "Hello World"
        title: Create a task
      - body: >-
          Use [task_rate](/docs/commander/mattermost/reference#task_rate). The
          command includes the optional parameters `<value>` and `<unit>` to set
          the rate, where `<value>` is a number and `<unit>` is one of: `minute,
          minutes, hour, hours, day or days`.


          Notes: After you set the rate, use `task_start` to start the task. If
          a task is running, it must be stopped with `task_stop` before the rate
          can be changed. 


          * View the task rate for `mytask`:
            > ##### /nc task_rate mytask
          * Set the task rate for mytask to 15 minutes:
            > ##### /nc task_rate mytask 15 minutes
          * Set the task rate for `mytask` to one day:
            > ##### /nc task_rate mytask 1 day
        title: View or set the task rate
      - body: >-
          Use task_start. You can also restart a task with this command after
          using `task_stop`.


          * Start `mytask`:

            > ##### /nc task_start mytask
        title: Start the task
      - body: >-
          Use [task_stop](/docs/commander/mattermost/reference#task_stop).
          Stopping a task doesn't delete it or change it, it just stops the task
          from running. You can view or set the schedule or rate of a task with
          the task_rate and task_interval commands. A task must be stopped to
          change its schedule or rate.


          * Stop `mytask`:

            > ##### /nc task_stop mytask
        title: Stop the task
      - body: >-
          Use [task_list](/docs/commander/mattermost/reference#task_list) to
          output a list of all tasks in the [current app]($the-current-app) and
          their states.


          * To list all tasks and their states:

            > ##### /nc task_list
        title: List all tasks
      - body: >-
          Use [task_info](/docs/commander/mattermost/reference#task_info) to
          show the following information about the task:


          * Name

          * Creator

          * Schedule or rate

          * Status (stopped or running). 

          * If the task was started or stopped, the time it started running or
          when it was stopped is shown.


          This information appears in the command output.


          * Show the task information for `mytask`:

            > ##### /nc task_info
        title: Get info about a task
      - body: >-
          Use [task_channel](/docs/commander/mattermost/reference#task_channel)
          to view or set the channel associated with a task.


          * View the channel used for `mytask`:
            > ##### /nc task_channel mytask

          If you’re setting or changing the task channel, be sure that the
          channel has been [created in your Mattermost app and added to
          Commander]($create-add-a-channel).


          * Set or change the task output channel for `mytask` to `#general`:
            > ##### /nc task_channel mytask #general
        title: View or set the channel for task
      - body: >-
          Use [task_delete](/docs/commander/mattermost/reference#task_delete) to
          delete a specific task.


          * Delete `mytask`:

            > ##### /nc task_delete mytask
        title: Delete a task
    body: >-
      Tasks run commands at scheduled times or at a given rate. 


      There are several commands to create and manage tasks. After creating a
      task, you can set its schedule or interval with
      [task_schedule](/docs/commander/mattermost/reference#task_schedule) or
      [task_rate](/docs/commander/mattermost/reference#task_rate) and then start
      the task running with
      [task_start](/docs/commander/mattermost/reference#task_start).
    title: Tasks
  - anchor-item:
      - anchor: 'Example: Create a trigger for a GitHub webhook'
        body: >-
          As an example, you might want to set up a webhook for Github push
          events where a Github push (a transfer of commits to a repository)
          causes a command to be run to notify users in a Mattermost channel
          that a push took place. Here’s the sequence of tasks to set this up,
          with detailed instructions following:


          1. Choose which Mattermost output channel you want to use (add a
          channel to Commander if you haven’t already)  and which command to
          trigger. In this case, we’ll use the existing #general channel and the
          print command that was in the [Quickstart Guide
          tutorial](/docs/commander/mattermost/quickstart#create-a-print-command)

          2. Create a trigger with an output channel and output message, using
          [trigger_create](/docs/commander/mattermost/reference#trigger_create).
          This command outputs an incoming URL in the Nimbella Cloud.

          3. Use this incoming URL to create an external webhook in GitHub that
          notifies the incoming URL each time there’s a push in the repository.


          Github has documentation about their webhooks on
          [developer.github.com](https://developer.github.com/webhooks/), but
          here are basic instructions:


          **To set up a trigger for a GitHub webhook to print Mattermost
          notifications when there’s a repository push:**


          1. In Mattermost, create a trigger called GHpushTrigger that writes
          the output from the `print` command to the #general channel:

           > ##### /nc trigger_create GHpushTrigger #general print “Hey there’s been a push in your GitHub repo!”
           >
           > ###### created trigger printTrigger with incoming URL https://agigcp.nimbella.com/AHC901230/nc/v1

          2. Copy the incoming URL in the response. 

          3. In GitHub, choose your repository.

          4. Click the **Settings** tab.

          5. Click **Webhooks** in the left sidebar.

          6. Click **Add Webhook**.

          7. In the **Payload URL** field, paste the incoming URL of the trigger
          you created.

          8. Select **application/json** as the **Content type**.

          9. Select **Just the push event**.

          10. Make sure the **Active** checkbox is selected and click **Save
          webhook**.


          Now any Github push event in the GitHub repository will cause the
          print command to be run and the output sent to the **\#general**
          channel. 


          ### Access GitHub event information


          When Github sends an event using a webhook, it puts information about
          the event in an "`X-Github-Event`" HTTP header. The `params.__trigger`
          variable in your command has all the HTTP headers and parameters of
          the incoming request, so you can access the Github event information
          with `params.__trigger.X-Github-Event`:


          ```

          JSON.stringify(params.__trigger.X-Github-Event, null, 2)

          ```
        title: 'Example: Create a trigger for a GitHub webhook with trigger_create'
      - body: >-
          ### Disable a trigger


          Use
          [trigger_disable](/docs/commander/mattermost/reference#trigger_disable).
          Disabling a trigger doesn't delete it or change it, it just stops the
          task from running the command.


          * Disable the `GHpushTrigger` trigger:
            > ##### /nc trigger_disable GHpushTrigger

          ### Re-enable a trigger


          The `trigger_create` command automatically enables the trigger, but if
          you run the `trigger_disable` command, you can re-enable the disabled
          trigger using
          [trigger_enable](/docs/commander/mattermost/reference#trigger_enable).


          * Re-enable `GHpushTrigger`:
            > ##### /nc trigger_enable GHpushTrigger

          ### Info about a trigger


          The [trigger_info](/docs/commander/mattermost/reference#trigger_info)
          command shows information about a trigger. 


          ### List all triggers


          Use the
          [trigger_list](/docs/commander/mattermost/reference#trigger_list)
          command to get a list of all the triggers in the [current
          app]($the-current-app). 


          * List all triggers in the current app:
            > ##### /nc trigger_list

          ### View/set the channel associated with a trigger:


          Use
          [trigger_channel](/docs/commander/mattermost/reference#trigger_channel).


          * View the channel associated with `GHpushTrigger`:
            > ##### /nc trigger_channel GHpushTrigger
          * Set the channel associated with `GHpushTrigger`:
            > ##### /nc trigger_channel GHpushTrigger #general

          ### Delete a trigger


          Use the
          [trigger_delete](/docs/commander/mattermost/reference#trigger_delete)
          command. 


          **Note:** If you delete a trigger, you should first delete the
          external webhook that is calling it so you don't end up with a webhook
          that continues to call an endpoint that doesn't exist.


          * Delete the `GHpushTrigger` trigger:
            > ##### /nc trigger_delete GHpushTrigger
        title: Other commands for managing triggers
    body: >-
      Triggers allow an external webhook to trigger execution of a command and
      output the results to a Mattermost channel. When a trigger is created, an
      incoming webhook URL is created for the trigger that you have set an
      external webhook to call when an event takes place.


      Like tasks, triggers aren't run by users, so they need a way to output to
      a Mattermost channel that you’ve [created and added to your
      app]($create-add-a-channel).
    title: Triggers
  - anchor-item:
      - body: >-
          Nimbella maintains links to commonly used command sets that can be
          installed using single-word names. For example, there is a `billing`
          command set that contains billing commands for common cloud services,
          such as Amazon Web Services. See the [Example command sets
          section]($example-command-sets) for a list of the example command sets
          available.


          **Note: **Many of the commands in the `billing` command set require
          API keys to allow the command source to obtain billing information
          from the various cloud providers. For example, to use the `awsbill`
          command, you must create secrets for `awsCostExplorerAccessKeyId`,
          `awsCostExplorerSecretAccessKeyId`, and `awsCostExplorerRegion`. See
          the [Secrets]($secrets) section for how to access information and API
          keys that need to be added to run the commands that require them. The
          various commands will output what API keys are required when they are
          run and what secrets are missing that they need.


          ### Install a command set


          * Install the `billing` command set in the [current
          app]($the-current-app), along with the  source for the commands:

            > ##### /nc csm_install billing

          Output: List of commands installed.


          Use [csm_commands](/docs/commander/mattermost/reference#csm_commands)
          at any time to see the list of commands that were installed in this
          command set:


          * List the commands installed with the `billing` command set:

            > ##### /nc csm_commands billing

          Customize and edit the source code of any of the installed commands
          using
          [command_code](/docs/commander/mattermost/reference#command_code) to
          get a link to edit the command's source code. 


          * Retrieve a link to the `awsbill` command’s source code:

            > ##### /nc command_code awsbill
        title: 'Example 1: Install the Nimbella billing command set'
      - body: >-
          The Github repository has a commands.yaml file in its root directory
          that contains the OpenCSI YAML definition of the command set. You can
          publish your own command set for others to use by putting a
          commands.yaml file for the command set into a GitHub repository. The
          commands.yaml file contains the definition of each command along with
          links to the source code for each command. 


          Anyone Installing this command set from Github would use the following
          command:


          > ##### /nc csm_install github:<name>/<project>
        title: 'Example 2: Install a command set from a GitHub repository'
      - body: >-
          A third way to install a command set from an external location is by
          specifying the full URL of the command set YAML definition. 


          * Install a command set YAML from the URL
          https://a.b.com/commands.yaml:

            > ##### /nc csm_install https://a.b.com/commands.yaml
        title: 'Example 3: Install a command set from a URL'
      - body: >-
          ### Update an externally loaded command set


          If an externally loaded command set is updated, you can update the
          source for all the commands from the source location with
          [csm_update](/docs/commander/mattermost/reference#csm_update).


          * Update the `billing` command set:

            > ##### /nc csm_update billing

          **Notes:** 


          * Any changes you made to the source code of the commands in the set
          are overwritten by running `csm_update`. 

          * Github runs a caching service in front of the Github web site, so if
          a command set is updated on Github an update may not immediately
          reflect the changes to the command set.


          ### List all the command sets and commands in each command set


          The [csm_list](/docs/commander/mattermost/reference#csm_list) command
          outputs all the command sets in the [current app]($the-current-app)
          and also all the commands in each command set. There are no
          parameters.


          * List all command sets and all commands in each set in the current
          app:

            > ##### /nc csm_list

            > ###### billing: awsbill, datadogbill

            The output shows there is one command set (`billing`) with two commands: `awsbill` and `datadogbill`

          ### List the commands in a specified command set


          Use [csm_commands](/docs/commander/mattermost/reference#csm_commands)
          to see the list of commands included in one command set:


          * List the commands installed with the `billing` command set:

            > ##### /nc csm_commands billing

          ### Show information about a command set


          The [csm_info](/docs/commander/mattermost/reference#csm_info) command
          provides the following information for a specified command set that
          was loaded with `csm_install`:


          * Name of the command set

          * URL location

          * Version number

          * Description of the command set


          **Note:** This command doesn’t work with command sets created with
          `csm_create`. 


          ### Uninstall a command set


          Use
          [csm_uninstall](/docs/commander/mattermost/reference#csm_uninstall) to
          uninstall a command set. 


          **Note:** This command also deletes all the source code for the
          commands in the set, even if the source has been modified. To prevent
          this, delete the command set instead.


          * Uninstall the `billing` command set:

            > ##### /nc csm_uninstall billing

          ### Delete a command set


          Use [csm_delete](/docs/commander/mattermost/reference#csm_delete) to
          delete a named command set. Only the command set is deleted – the
          commands in the set are unaffected by this command. If you want to
          delete the commands as well, use the
          [csm_uninstall](/docs/commander/mattermost/reference#csm_uninstall)
          command instead.


          * Delete the billing command set from the current app:

            > ##### /nc csm_uninstall myset
        title: Commands to manage command sets
      - body: >-
          First, create a command set, then add and remove commands in a second
          step.


          ### Create a command set


          Use the [csm_create](/docs/commander/mattermost/reference#csm_create)
          command to create an internal command set. 


          * Create a command set called `myset`:

            > ##### /nc csm_create myset 

          ### Add and remove commands


          Use [csm_commands](/docs/commander/mattermost/reference#csm_commands)
          to add and remove commands from a command set. Use plus signs to add
          and minus signs to remove. Leave a space after the plus or minus sign.


          * Add the commands `mycommand1` and `mycommand2` to the `myset`
          command set:

            > ##### /nc csm_commands myset + mycommand1 + mycommand2

          The `csm_commands` command without the optional parameters lists the
          commands included in this command set.


          ### Export an OpenCSI definition of your internal command set

           The [csm_export](/docs/commander/mattermost/reference#csm_export) command outputs an [OpenCSI](/docs/commander/mattermost/opencsi) definition for a command set. You can copy that definition to an external location, such as into a commands.yaml file in a Github repository, then put in references to the source code for the commands.

          * Output an OpenCSI definition for the `myset` command set:

            > ##### /nc csm_export myset
        title: Create and manage a custom command set
      - body: >-
          A large number of pre-built command sets are available. All command
          sets include source code.


          The list of command sets that can be installed with single word names
          is available here:


          https://github.com/nimbella/command-sets


          See [Example 1]($example-1-install-the-nimbella-billing-command-set)
          for how to install and view the commands in the `billing` command set.
        title: Example command sets
    body: >-
      Command sets can be used to install, manage or publish a set of commands.
      A command set contains the definition of each command in the set,
      including the command's name, parameters, and a description. A command set
      also includes the source code for each command in the set. 


      Command sets are defined by a YAML file in OpenCSI Specification format.
      The YAML file includes links to the source code for each command. Put the
      YAML file in a web-accessible location, along with the source code for
      each command. Installing the command set using the
      [csm_install](/docs/commander/mattermost/reference#csm_install) command
      brings in the commands and their source, so the source can be customized
      at the new location. The process is similar to installing npm  (Node
      Package Manager) packages.


      You can install publicly available command sets in several different ways,
      as shown in the following examples.
    title: Command Sets
  - anchor-item:
      - body: >-
          When you add an app to Commander, an account is automatically created
          for you and tied to your Mattermost workspace. All apps added to the
          same Mattermost workspace share the same account.


          Accounts have plan information (paid/unpaid) and various limits
          associated with them. 


          * To view the account information associated with your Mattermost
          workspace, including the plan and limits, use
          [account_info](/docs/commander/mattermost/reference#account_info).

          * If you want to increase your account limits and upgrade your plan,
          use the
          [account_upgrade](/docs/commander/mattermost/reference#account_upgrade)
          command to start the upgrade process for your Mattermost workspace.
          This command outputs a web link that will take you to a web page
          showing your upgrade options and various plan costs.
        title: Manage Accounts
    body: >-
      You’ll notice when you install the Commander app in Mattermost, it doesn’t
      ask for permissions to read messages. Commander does not read messages in
      any channel, it is output only and only responds to slash commands
      connected to commander.  All connections from Mattermost to Commander must
      be explicitly made by a Mattermost workspace administrator.


      When you configure Commander, it doesn’t read any of your messages. It
      isn’t a bot and it can’t create custom slash commands on its own. It also
      doesn’t have access to any of your channels unless you explicitly permit
      it to post in a channel. This is by design to ensure that Commander only
      does what you explicitly allow it to do.


      For example, if you want a Commander [task]($tasks) to post a message in a
      Mattermost channel, you must create an incoming webhook URL for the
      channel and give that webhook URL to Commander with the `channel_add`
      command. That isn't necessary for slash commands that users type into a
      channel. When your custom Mattermost app is in your workspace and you type
      custom commands, it has permission to post in the channel the command is
      run from.


      User and team identities are automatically managed by Mattermost. When
      slash commands are executed, Commander ensures Mattermost is the caller
      using a shared secret key. HTTPS is used for all communications.
      Internally, Commander uses the Nimbella Cloud. In the Nimbella Cloud, each
      command function executes in an isolated container, with its environment
      separated from other containers. Apps in Commander are each separated by
      namespaces with their own authorization keys.
    title: Security
  - body: >-
      The free version of Commander has limitations in terms of commands, tasks,
      and triggers and only allows commands to be written in JavaScript.
      Upgrades are available on a Mattermost workspace (team) basis to give all
      apps in the workspace higher limits and enable more features. Upgrades
      include the ability to allow direct development using the Nimbella
      workbench. 


      See the [pricing page](https://nimbella.com/pricing/commander#mattermost)
      for more information.
    title: Upgrading
meta:
  description: >-
    Mattermost allows the use of custom apps, which are accessed in Mattermost
    by means of Slash Commands. When a user types a specific slash command like
    /times, it sends a message to a public URL. The request includes the command
    and any additional text following the command. Mattermost calls the public
    URL a Request URL.
  title: Developer Guide
---

